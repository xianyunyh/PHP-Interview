## mysql优化

- 不要查询不需要的列

- 不要在多表关联返回全部的列

- 不要select *

- 不要重复查询，应当写入缓存

- 尽量使用关联查询来替代子查询。

- 尽量使用索引优化。如果不使用索引。mysql则使用临时表或者文件排序。如果不关心结果集的顺序，可以使用order by null 禁用文件排序。

- 优化分页查询，最简单的就是利用覆盖索引扫描。而不是查询所有的列

- 应尽量避免在 where 子句中使用 !=或<> 操作符，否则将引擎放弃使用索引而进行全表扫描。

- 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

```sql
select * from user where name is null
```

- 尽量不要使用前缀%

```sql
select * from user where name like '%a'
```

- 应尽量避免在 where 子句中对字段进行表达式操作

- 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描

- 很多时候用 exists 代替 in 是一个好的选择：

- 

## btree索引

B-TREE索引适合全键值、键值范围、前缀查找。

全值匹配，是匹配所有的列进行匹配、

匹配最左前缀。比如 a=1&b=2 那么会用到a的索引

匹配列前缀。 比如 abc abcd %abc

匹配范围 比如 in(3,5)

### 限制

- 如果不是左前缀开始查找，无法使用索引 比如 %aa 

- 不能跳过索引的列。

- 需要中，含有某个列的范围查找，后面的所有字段都不会用到索引

### 索引的优点

1、减少服务器扫描表的次数

2、避免排序和临时表

3、将随机io变成顺序io

### 高性能索引策略

- 1、使用独立的列，而不是计算的列

where num+1 =10 //bad

where num = 9 //good

- 2、使用前缀索引
- 3、多列索引，应该保证左序优先
- 4、覆盖索引
- 5、选择合适的索引顺序

不考虑排序和分组的情况。在选择性最高的列上，放索引，

- 6、使用索引扫描来排序

mysql有两种方式生成有序的结果，一种是排序操作，一种是按索引顺序扫描，如果explain处理的type列的值是index。则说明mysql使用了索引

只有当索引的列顺序和order by子句的顺序一致的时候，并且所有的顺序都一致的时候。mysql才能使用索引进行排序。

### 不能使用索引的情况

- 1.查询使用了两种排序方向

```sql
select * from user where login_time > '2018-01-01' order by id des ,username asc #
```

- 2.order by中含有了一个没有 索引的列

```sql
select * from user where name = '11' order by age desc; //age 没有索引
```

- 3.where 和 order by 无法形成最左前缀

- 索引列的第一列是范围条件

- 在索引列上有多个等于条件，这也是一种范围。不能使用索引

https://blog.csdn.net/samjustin1/article/details/52212421


